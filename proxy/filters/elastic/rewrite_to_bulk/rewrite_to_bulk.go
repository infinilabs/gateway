/* Copyright Â© INFINI LTD. All rights reserved.
 * Web: https://infinilabs.com
 * Email: hello#infini.ltd */

package rewrite_to_bulk

import (
	"fmt"
	log "github.com/cihub/seelog"
	"github.com/savsgio/gotils/bytes"
	"infini.sh/framework/core/config"
	"infini.sh/framework/core/global"
	"infini.sh/framework/core/pipeline"
	"infini.sh/framework/core/util"
	"infini.sh/framework/lib/bytebufferpool"
	"infini.sh/framework/lib/fasthttp"
	"strings"
)

type RewriteToBulk struct {
	Prefix            string `config:"prefix" `
	AutoGenerateDocID bool   `config:"auto_generate_doc_id" `
	RemovedType       bool   `config:"type_removed" `
}

func init() {
	pipeline.RegisterFilterPluginWithConfigMetadata("rewrite_to_bulk", New, &RewriteToBulk{})
}

func New(c *config.Config) (pipeline.Filter, error) {

	runner := RewriteToBulk{
		AutoGenerateDocID: true,
	}

	if err := c.Unpack(&runner); err != nil {
		return nil, fmt.Errorf("failed to unpack the filter configuration : %s", err)
	}

	return &runner, nil
}

func (filter *RewriteToBulk) Name() string {
	return "rewrite_to_bulk"
}

func (filter *RewriteToBulk) Filter(ctx *fasthttp.RequestCtx) {

	path := string(ctx.PhantomURI().Path())
	valid, indexPath, typePath, idPath := ParseURLMeta(path)
	if global.Env().IsDebug {
		log.Debugf("rewrite_to_bulk: %v => %v, %v, %v, %v", path, valid, indexPath, typePath, idPath)
	}
	if valid {

		routing:=ctx.PhantomURI().QueryArgs().Peek("routing")
		pipeline:=ctx.PhantomURI().QueryArgs().Peek("pipeline")

		action:="index"
		if typePath=="_update"{
			action="update"
			typePath=""
		}else if typePath=="_create"{
			action="create"
			typePath=""
		}else if typePath=="_delete"||ctx.IsDelete(){
			action="delete"
			typePath=""
		}

		if idPath == "" && filter.AutoGenerateDocID {
			idPath = util.GetUUID()
			if filter.Prefix != "" {
				idPath = filter.Prefix + idPath
			}
			ctx.Request.Header.Set("X-Generated-ID", idPath)
			ctx.Response.Header.Set("X-Generated-ID", idPath)
		}

		//url
		uri := ctx.Request.CloneURI()
		uri.SetPath(fmt.Sprintf("/%s/_bulk", indexPath))
		ctx.Request.SetURI(uri)
		fasthttp.ReleaseURI(uri)

		docBuf := bytebufferpool.Get("rewrite_to_bulk")
		defer bytebufferpool.Put("rewrite_to_bulk", docBuf)

		//write index part
		if indexPath == "" {
			panic("index can't be nil")
		}

		docBuf.WriteString(fmt.Sprintf("{ \"%v\" : { \"_index\" : \"%s\" ", action,indexPath))
		//write type part
		if typePath != "" &&!filter.RemovedType {
			docBuf.WriteString(fmt.Sprintf(", \"_type\" : \"%s\" ", typePath))
		}
		//write id part
		if idPath != "" {
			docBuf.WriteString(fmt.Sprintf(", \"_id\" : \"%s\" ", idPath))
		}

		if routing != nil {
			docBuf.WriteString(fmt.Sprintf(", \"routing\" : \"%s\" ", string(routing)))
		}

		if pipeline != nil {
			docBuf.WriteString(fmt.Sprintf(", \"pipeline\" : \"%s\" ", string(pipeline)))
		}

		//write final part
		docBuf.WriteString("} }\n")

		if action!="delete"{
			body := ctx.Request.Body()
			util.WalkBytesAndReplace(body, util.NEWLINE, util.SPACE)
			docBuf.Write(bytes.Copy(body))
			docBuf.WriteString("\n")
		}

		ctx.Request.SetBody(bytes.Copy(docBuf.Bytes()))
	}
}

func ParseURLMeta(pathStr string) (valid bool, urlLevelIndex, urlLevelType, id string) {

	if strings.Index(pathStr, "//") >= 0 {
		pathStr = strings.ReplaceAll(pathStr, "//", "/")
	}

	if strings.LastIndex(pathStr, "/") == 0 {
		return false, urlLevelIndex, urlLevelType, id
	}

	if util.SuffixStr(pathStr, "/") {
		pathStr = util.TrimRightStr(pathStr, "/")
	}

	pathArray := strings.Split(pathStr, "/")

	last := pathArray[len(pathArray)-1]

	//only _doc and _create are valid for create new doc
	if util.PrefixStr(last, "_") && !util.ContainsAnyInArray(last, []string{"_create", "_doc"}) {
		return false, urlLevelIndex, urlLevelType, id
	}

	switch len(pathArray) {
	case 5:
		urlLevelIndex = pathArray[1]
		urlLevelType = pathArray[2]
		id = pathArray[3]
		break
	case 4:
		urlLevelIndex = pathArray[1]
		urlLevelType = pathArray[2]
		id = pathArray[3]
		break
	case 3:
		urlLevelIndex = pathArray[1]
		urlLevelType = pathArray[2]
		break
	case 2:
		urlLevelIndex = pathArray[1]
		return false, urlLevelIndex, urlLevelType, id
	}

	if util.SuffixStr(urlLevelIndex, "_") {
		return false, urlLevelIndex, urlLevelType, id
	}

	return true, urlLevelIndex, urlLevelType, id
}
